	\documentclass[fleqn, 12pt]{article}
	\usepackage[latin1]{inputenc}
	\usepackage[ngerman]{babel}
	\usepackage[a4paper,text={155mm,220mm},centering,headsep=10mm,footskip=15mm]{geometry}
	\usepackage{etex}
	\usepackage{graphicx}
	\usepackage{amssymb}
	\usepackage{graphicx}
	\usepackage{multirow}
	\usepackage{multicol}
	\usepackage{xcolor}	
	\usepackage{float}
	\usepackage{pdfpages}
	\usepackage{todonotes}
	\usepackage{pst-plot}
	\usepackage{pstricks}
	\usepackage{pstricks-add}
	\usepackage{pst-node}
	\usepackage{pst-grad,multido} 
	\usepackage{verbatim}
	\usepackage[font=small, labelfont=bf, format=plain, indention=1cm]{caption}
	\usepackage{fixltx2e}
	\title{}
	\date{}
	\author{}
	\usepackage{array}
	\usepackage{amsmath}
	\usepackage{fancyhdr}
	\usepackage{enumitem} 
	\parindent0pt
	%\usepackage[format=plain, justification=RaggedRight, singlelinecheck=false]{caption}
	\usepackage{blindtext}
	
	% Listings
	\usepackage{listings}
	\renewcommand{\lstlistlistingname}{Liste der Quellcode Ausschnitte}
	\renewcommand{\lstlistingname}{Quellcode Ausschnitt}
		\definecolor{lsgreen}{rgb}{0,.5,0}
		\definecolor{lsred}{rgb}{.7,0,0}
		\definecolor{lsorange}{rgb}{.9,.5,0}
		\definecolor{lsgray}{rgb}{.5,.5,.5}
		\lstset{
			frame=tb,
			aboveskip=10mm,
			belowskip=10mm,
			showstringspaces=false,
			columns=flexible,
			captionpos=b,
			basicstyle={\normalsize\ttfamily},
			numbers=left,
			numberstyle=\tiny\color{lsgray},
			keywordstyle=\color{blue},
			commentstyle=\color{lsorange},
			stringstyle=\color{lsgreen},
			breaklines=true,
			breakatwhitespace=true,
			rulecolor=\color{lsgray},
			xleftmargin=7mm,
			tabsize=3
		}
	
	% Needed for proper display of links in bibliography
	\usepackage{url}	
	
	% Hyperref
	\usepackage[
	pdfauthor={Laura Anger, Timo \dots, Lukas Kolhagen},
	pdftitle={BVA Bewegungsanalyse},
	pdftoolbar=true,	
	colorlinks=true,
	linkcolor=blue,
	citecolor=blue,
	urlcolor=blue,
	linktocpage=true
	]{hyperref}
	\usepackage{bookmark}
	\bookmarksetup{
	numbered
	}
	\urlstyle{same}
	
	\pagestyle{fancy}
	\fancyhf{}
	\fancyhead[LO]{BVA}
	\fancyhead[CO]{Bewegungsanalyse in einer Videosequenz}
	\fancyhead[RO]{\thepage}
	\renewcommand{\headrulewidth}{0.5pt}
	\newcommand{\Absatzbox}[1]{\parbox[0pt][2em][c]{0cm}{}}
	
	% Itemize symbol
	\renewcommand{\labelitemi}{$\triangleright$}
	
	% Colors
	\definecolor{yellow}{rgb}{.95,.85,0}
	\definecolor{green}{rgb}{0,.8,0}
	\definecolor{blue}{rgb}{0,0,.8}
	\definecolor{red}{rgb}{.8,0,0}
	\definecolor{grey}{rgb}{.4,.4,.4}
	\definecolor{orange}{rgb}{.9,.5,0}
	
	% Macro for typesetting C++
	\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}

\begin{document}
\thispagestyle{empty}
	%\sffamily
			\begin{center}
			\includegraphics[width=.35\textwidth]{logo_TH}\\[20ex]
			{\Huge\textbf{Projektdokumentation}}\\[8ex]
			\rule{.8\textwidth}{.2pt}
			{\Large Bewegungsanalyse einer Videosequenz\\[1ex] mit dem Ansatz des Papers
			von Aach und Kunz}\\
			\rule{.8\textwidth}{.2pt}\\[10ex]
			von\\[2ex]
			\begin{tabular}{ll}
			Laura Anger &(Matrikelnr. 11086356)\\ 
			Timo Breuer &(Matrikelnr. 11089822)\\ 
			Lukas Kolhagen &(Matrikelnr. 11084355)\\
			\end{tabular}\\[10ex]
			Durchgeführt im\\ \textbf{Master Medientechnologie}\\ im\\ 
			\textbf{Sommersemester 2016}\\			
			\end{center}
			\vfill
			\begin{flushleft}
			{\bf Betreuer:}\\
			Prof. Dr. Dietmar Kunz\\
			Institut für Medien- und Phototechnik
			\end{flushleft}
	\newpage
	\tableofcontents
	\newpage
	\section{Einleitung}
	Diese Ausarbeitung ist Teil der Abschlussprojekt-Dokumentation im Modul "`Weiterführende Themen der Bildverarbeitung"' im Master Medientechnologie an der Technischen Hochschule Köln.
	
	Das Projekt beschäftigte sich mit der Bewegungsanalyse einer Videosequenz mit dem Ansatz des Papers von Aach und Kunz\textsuperscript{\cite{aach1998bayesian}}. Es wurde bearbeitet von Laura Anger, Timo Breuer und Lukas Kolhagen.
	\subsection{Ansatz im Paper von Aach und Kunz}
	Die Grundlage für das vorliegende Projekt bildet das Paper "`Bayesian motion estimation for temporally recursive noise reduction in X-ray fluoroscopy"'. Dieses beschäftigt sich mit der Entwicklung einer robusten Methode zur Bewegungsschätzung für die speziellen Anforderungen der stark rauschenden Aufnahmen einer Röntgen-Fluoroskopie.\\
	Der Ansatz beruht auf der Modellierung drei essenzieller Faktoren:
	\begin{description}
		\item [Datenterm:] Unterschied der Grauwerte zweier aufeinander folgender Bildern.
		\item [Örtliche Kohärenz:] Außer an Randbereichen von Objekten, bewegen sich Nachbarschaften meist in die gleiche Richtung.
		\item [Zeitliche Kohärenz:] Bewegungen verlaufen normalerweise kontinuierlich, sodass sich ein Bildblock zwischen zwei Bildern wahrscheinlich in dieselbe Richtung weiterbewegt oder die Richtung nur gering ändert.
	\end{description}
	Eine genaue Beschreibung dieser Faktoren erfolgt in \ref{sec:Datenterm}, \ref{sec:oertlich} und \ref{sec:zeitlich}.\\
	
	\subsection{Projektziel}
	Die Zielsetzung für das Projekt "`Bewegungsanalyse einer Videosequenz"' war eine Über\-tra\-gung des Ansatzes von Röntgenbildern auf normale Videosequenzen. Infolge dessen war eine Vernachlässigung der speziellen Anforderung des Bildrauschens möglich, da Röntgenbilder -- insbesondere als Teil einer Fluoroskopie -- zum Schutz des Patienten und des medizinischen Personals nur sehr geringe Röntgendosen enthalten dürfen und deshalb ein extrem schlechtes Signal-zu-Rauschverhältnis aufweisen. Diese Problematik besteht bei normalen Videosequenzen nicht, weshalb für die Untersuchung von vergleichsweise geringem und etwa gleich verteiltem Rauschen ausgegangen werden konnte.
	
\section{Verfahren}
	In \cite{aach1998bayesian} wird das Verfahren, was dieser Ausarbeitung zu Grunde liegt beschrieben. Es handelt sich dabei um ein Block-Matching-Verfahren auf Grundlage des Satzes von Bayes. Im Folgenden wird das Verfahren erläutert und auf die Änderungen im Algorithmus eingegangen, welche erfolgt sind, um das Verfahren für normale Bildsequenzen anzupassen.
	
\subsection{Bewegungsschätzung}
Um zu verstehen, wie die Bewegungsschätzung im einzelnen funktioniert, muss man sich zunächst 
klar machen, wie das geschätzte Bewegungsvektorfeld überhaupt definiert ist.\\

\begin{figure}[H]
		\centering
		\includegraphics[bb=0 0 256 256, scale=0.5]{beziehung-bild-bewegungsfeld.png}
		\caption{Beziehung zwischen Bewegungsvektorfeld und Einzelbildern \cite{aach1998bayesian}.}
		\label{fig:beziehung}
	\end{figure}

In Abbildung \ref{fig:beziehung} sieht man drei Frames einer Bildsequenz. $Y_{n}$ steht hierbei für das $n$-te Bild dieser Sequenz und $y_{n}(k)$ ist der Grauwert des Pixels an der Stelle $k$. Das $k$ steht für ein Koordinatenpärchen ($k_{x},k_{y}$) und es gilt $k=1,\dots,N$, wobei $N$ die Anzahl der Pixel eines Frames ist. Der eingezeichnete Vektor $v_{n}(k)$ ist derjenige Vektor, der auf $k$ addiert wird, sodass sich die Position des entsprechenden Pixels im vorherigen Bild ergibt. All diese Bewegungsvektoren zusammengenommen ergeben das Bewegungsvektorfeld eines Frames, welches in der Abbildung mit $V_{n}$ bezeichnet wird. \\
Das geschätzte Bewegungsvektorfeld $\hat{V}_{n}$ ergibt sich nach den Ausführungen von Aach und Kunz zu: 
	
\begin{equation}
	\hat{V}_{n}=\arg\ \smash{\displaystyle\max_{V}} \left[p\left(Y_{n},  Y_{n-1},\vert V\right)\cdot p\left(\hat{V}_{n-1} \vert V\right)\cdot p(V)\right]
	\label{eq:bayes}
\end{equation}\\
	
Da es sich um einen bayesschen Ansatz handelt, gilt es sich mit bedingten Wahrscheinlichkeiten auseinander zu setzen. Der erste Faktor der Formel \ref{eq:bayes} ist im Originalansatz zur Modellierung des Rauschens gedacht. Es ist davon auszugehen, dass Röntgenbilder weit aus mehr verrauscht sind, als reale Bildsequenzen auf die das vorliegende Verfahren angewandt werden soll. Deshalb liegt es nahe, dass Rauschen weitgehend zu vernachlässigen und durch einen reinen Datenterm zu ersetzen. Mehr Details dazu kann man in Kapitel \ref{sec:Datenterm} nachlesen. Bei den beiden anderen Faktoren handelt es sich zum einen um die örtliche und zum anderen um die zeitliche Kohärenz. Beide werden in den Kapiteln \ref{sec:oertlich} bzw. \ref{sec:zeitlich} näher beschrieben.
		
		\subsection{Kostenfunktion}\label{sec:costFunc}\todo[inline]{Alle}
			\subsubsection{Datenterm}\label{sec:Datenterm}
			Der Datenterm als Teil der zu minimierenden Kostenfunktion hat die Aufgabe, die Veränderung der Grauwerte beim Vergleich zweier Bilder zu quantifizieren. Da angenommen wird, dass diese gemessenen Veränderungen nur durch Bewegung und Rauschen verursacht wird, lässt sich das Rauschen selbst modellieren, indem vor dem Vergleich der Bilder die tatsächliche Bewegung herausgerechnet, also eins der Bilder entsprechend des zuvor ermittelten Bewegungsvektors verschoben wird.
			
			Der zu minimierende Ausdruck für die Modellierung des Rauschens für ganze Bilder lautet:
			\begin{equation}
				p(Y_n,Y_{n-1}|V)=c'\cdot e^{-\displaystyle\sum\limits_{\vec{k}}{\frac{\left[d\left(\vec{k},\vec{v}\left(\vec{k}\right)\right)\right]^2}{4\cdot\sigma^2\left(\vec{k}\right)}}}
				\label{eq:noise}
			\end{equation}
			
			Da ebenfalls angenommen wird, dass die Bewegung über das ganze Bild nicht konstant ist, wird das Bild in Blöcke unterteilt. Des weiteren führt die Übertragung des eigentlichen Problems von Röntgenbildern auf normale Bildsequenzen zu der Erkenntnis, dass die Poisson-Verteilung des Rauschens bei Röntgenbildern aufgrund der niedrigen Anzahl von Röntgenquanten, bei normalen Bildern in eine Normalverteilung übergeht. Aus diesem Grund kann der Term unter dem Bruchstrich im Exponenten von Gleichung~\ref{eq:noise} vernachlässigt werden. Da der verbleibende Ausdruck von Gleichung~\ref{eq:noise} minimal wird, wenn der Exponent der Exponentialfunktion minimal wird, genügt für das Minimierungsproblem
			\begin{equation}
				d\left(\vec{k},\vec{v}\left(\vec{k}\right)\right)=y_n\left(\vec{k}\right)-y_{n-1}\left(\vec{k}+\vec{v}\left(\vec{k}\right)\right)
			\end{equation}
			wobei $y_n\left(\vec{k}\right)$ der aktuelle Block und $y_{n-1}\left(\vec{k}+\vec{v}\left(\vec{k}\right)\right)$ der zu vergleichende Block des vorherigen Bildes, verschoben um $\vec{v}\left(\vec{k}\right)$ ist.\\
			
			Um etwaige Probleme am Rand des Bildes zu verhindern, wurde eine Randbehandlung implementiert, welche verhindert, dass Blockadressen im vorherigen $y_{n-1}$-Bild außerhalb der Bildgrenzen liegen.
			\subsubsection{Örtliche Kohärenz}\label{sec:oertlich}

Die örtliche Kohärenz trägt als gewichteter Regularisierungsterm zur Kostenfunktion bei.
Bei der Bestimmung der örtlichen Kohärenz wird von der Annahme ausgegangen, dass benachbarte Regionen in Bildfolgen ähnliche Bewegungsrichtungen aufweisen.
Hierzu werden neben dem neuen möglichen Bewegungsvektor der untersuchten Bildposition die Bewegungsvektoren der jeweiligen 8ter-Nachbarschaft betrachtet.
Über die Differenzen des Bewegungsvektor und der benachbarten Bewegungsvektoren ergibt sich eine a-priori-Wahrscheinlichkeitsdichte.
Ziel ist daher die Minimierung des Exponenten der Wahrscheinlichkeitsdichte:

\begin{equation}
E_L\left(\vec{k},V\right) = \sum_{\vec{l} \epsilon N(\vec{k})} g_{\vec{l}} \left|\left| \vec{v}\left(\vec{k}\right) - \vec{v}\left(\vec{l}\,\right) \right|\right|_2^{\nu}
\end{equation}

Der Faktor $g_{\vec{l}}$ gewichtet die normierte Differenz abhängig von der Position des betrachteten benachbarten Bewegungsvektor.
Über den Parameter $\nu$ kann die verallgemeinerte Normalverteilung angepasst werden. 
Die Normalverteilung ($\nu=2$) glättet das Bewegungsvektorfeld zu stark.
Für $\nu=1.3$ ergibt sich eine praktikable Parametrisierung.\textsuperscript{\cite{aach1998bayesian}} \\

Die Implementierung berechnet demnach die Summe bestehend aus den gewichteten normierten und mit dem Parameter $\nu$ potenzierten Differenzen.
Hierzu wird neben dem Index der aktuell untersuchten Bildposition/-region der Listenindex des neuen möglichen Bewegungsvektors benötigt.
Mit Hilfe des Index der untersuchten Bildposition können dann die benötigten Positionen der Nachbarregionen bestimmt werden. 
Zu beachten ist hierbei, dass für Randbereiche weniger Nachbarregionen untersucht werden bzw. nicht vorhanden sind.
Nachdem die Differenzen gemäß dem euklidischen Abstand normiert sind, werden diese mit dem Parameter $\nu$ potenziert.
Das Ergebnis wird für horizontale und vertikale Nachbarregionen mit dem Faktor $g_l=1$ und für diagonale Nachbarregionen mit dem Faktor $g_l=0.5$ gewichtet. Anschließend werden die gewichteten Ergebnisse aufsummiert und zurück gegeben.			
			
			\subsubsection{Zeitliche Kohärenz}\label{sec:zeitlich}
			Da Bewegungen normalerweise gleichmäßig ablaufen -- wenn sie nicht gerade beginnen oder enden -- basiert die zeitliche Kohärenz darauf, dass die Bewegung (z.\,B. im aktuellen Block) der Bewegung im gleichen Block des vorherigen Bildes ähnlich ist. Für die Berechnung der Kosten folgt als Minimierungsterm aus
			\begin{equation}
				p\left(\hat{V}_{n-1}|V\right)=c\cdot e^{\displaystyle-\lambda_T\sum\limits_{\vec{k}}\left|\left|\hat{\vec{V}}_{n-1}\left(\vec{k}\right)-\vec{v}\left(\vec{k}\right)\right|\right|^\nu_2}
			\label{eq:}
			\end{equation}
			
			dass wieder nur der Exponent der Exponentialfunktion ausgewertet werden muss, da der gesamte Ausdruck minimal wird, wenn der Exponent minimal wird.
			
			\subsection{Programmablauf} \label{sec:programmAblauf}
		Der Programmablauf des ImageJ-Plug-Ins in Form der \texttt{run()}-Methode, die aufgrund des implementierten \texttt{PlugInFilter}-Interfaces überschrieben werden muss, ist in Abbildung~\ref{fig:programmAblauf} dargestellt.\\
		Grob betrachtet, werden in der \texttt{run()}-Methode drei \texttt{for}-Schleifen geschachtelt ausgeführt. Die innerste Schleife läuft über jeden Block des Bildes und bestimmt für diesen den Bewegungsvektor mit den geringsten Kosten aus den 14 berechneten Alternativen. Die Blockgröße ist variabel und kann z.\,B. $8\times8$ betragen.\\
		Die nächst äußere Schleife ist für die Iterationen zuständig. In den Iterationen wird innerhalb eines Bildes des Input-Stacks das Bewegungsvektorfeld mehrfach berechnet und jeweils das zuletzt berechnete Ergebnis als Grundlage für die nächste Berechnung verwendet. Dies ist erforderlich, um die Abweichung der Bewegungsvektoren pro Frame so gering wie möglich zu halten. Gleichzeitig hängt die Wahl der Anzahl der Iterationen natürlich davon ab, welche Performanz die Berechnung erreichen soll, also wie schnell ein Ergebnis benötigt wird.\\
		Die äußere Schleife läuft über den Stack und sorgt somit dafür, dass die Berechnungen pro Block und Iteration jeweils für jedes Bild des Input-Stacks erfolgen.\\
		Sobald ein Bild fertig bearbeitet ist, die äußere Schleife also einen Durchlauf absolviert hat, wird der Fortschrittsbalken im ImageJ-Fenster aktualisiert, damit der Benutzer eine Rückmeldung bekommt, wie weit die Berechnung fortgeschritten ist.\\
		Zuletzt wird in der \texttt{run()}-Methode noch das Ausgabefenster, in welchem der Input-Stack inklusive der überlagerten Bewegungsvektorfelder dargestellt wird, generiert und dessen Methode zur Anzeige aufgerufen.
		\begin{comment}
			\begin{figure}[h!]
			\centering
					\begin{psmatrix}[rowsep=0.3,colsep=0.4]
						\rnode{run}{\psframebox[fillstyle=solid,fillcolor=black]{\footnotesize\color{white}public void run(ImageProcessor ip)}}\\
						\rnode{readStack}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Read data from stack}}\\
						\rnode{initialize}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Initialize first motion vector field with zero vectors}}\\
						\rnode{forI}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize\texttt{$i=0$}}}\\
						\dianode[fillstyle=solid,fillcolor=red!30]{condStackSize}{\footnotesize$i<$ \texttt{stack size}?}\\[3mm]
						\dianode[fillstyle=solid,fillcolor=red!30]{frameNotZero}{\footnotesize$i\not=$ \texttt{0}?}\\[3mm]
						\rnode{curFrame}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Set current frame to i}}\\
						\rnode{forJ}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize\texttt{$j=0$}}}\\
						\dianode[fillstyle=solid,fillcolor=red!30]{condIter}{\footnotesize$j<$ \texttt{iterations}?}\\[3mm]
						\rnode{Vn}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Set current vector field as previous}}\\
						\rnode{forK}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize\texttt{$k=0$}}}\\
						\dianode[fillstyle=solid,fillcolor=red!30]{condNumBlocks}{\footnotesize$k<$ \texttt{number of blocks}?}\\[3mm]
						\rnode{calcAlt}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Calculate 14 alternatives for block k}}\\
						\rnode{minimizeCost}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Minimize cost function for alternatives}}\\
						\rnode{addVec}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Add vector with minimal cost to motion vector field}}\\
						\rnode{updateProgress}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Update plug-in progress}}\\
						\rnode{genMVF}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Generate motion vector field visualization for current frame}}\\
						\rnode{addToOutStack}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Add motion vector field to output stack}}\\
						\rnode{outWindow}{\psframebox[linearc=0.05,cornersize=absolute,fillstyle=solid,fillcolor=black!10]{\footnotesize Generate and display output window}}\\
					\end{psmatrix}
					\psset{arrows=->,nodesep=0pt}
					\ncline{run}{readStack}
					\ncline{readStack}{initialize}
					\ncline{initialize}{forI}
					\ncline{forI}{condStackSize}
					\ncline{condStackSize}{frameNotZero}\nbput{\footnotesize\color{green}True}
					\ncangle[angle=0, linearc=.1]{frameNotZero}{genMVF}\nbput[npos=.15]{\footnotesize\color{red}False}
					\ncline{frameNotZero}{curFrame}\nbput{\footnotesize\color{green}True}
					\ncline{curFrame}{forJ}
					\ncline{forJ}{condIter}					
					\ncline{condIter}{Vn}\nbput{\footnotesize\color{green}True}
					\ncline{Vn}{forK}
					\ncline{forK}{condNumBlocks}
					\ncline{condNumBlocks}{calcAlt}\nbput{\footnotesize\color{green}True}
					\ncline{calcAlt}{minimizeCost}
					\ncline{minimizeCost}{addVec}
					\ncline{addVec}{updateProgress}
					\ncangle[arm=3cm, angle=180, linearc=.1]{condIter}{updateProgress}\nbput[npos=.25]{\footnotesize\color{red}False}
					\ncangle[arm=1.8cm, angle=0, linearc=.1]{condNumBlocks}{condIter}\nbput[npos=.25]{\footnotesize\color{red}False}
					\ncline{updateProgress}{genMVF}
					\ncline{genMVF}{addToOutStack}
					\ncline{addToOutStack}{outWindow}
					\ncangle[arm=2.8cm, angle=180, linearc=.1]{condStackSize}{outWindow}\nbput[npos=.2]{\footnotesize\color{red}False}
			\caption{Programmablauf}
			\label{fig:programmAblauf}
		\end{figure}
\end{comment}		
			
\subsection{Visualisierung}
	Um die Bewegungsvektorfelder darzustellen, wird sich mit Symbolen beholfen. Diese werden 				blockweise  über die Videosequenz gelegt. Aus Darstellungsgründen wird das Video dazu um Faktor 	4 in beide Bildrichtungen hoch skaliert. Da die einzelnen Bewegungsvektoren immer zwischen zwei 		Frames berechnet werden, wird genau ein Bewegungsvektorfeld weniger erzeugt, als das 					Eingangsmaterial Frames hat. \\
	Bei den bereits erwähnten Symbolen handelt es sich um Kreise und Pfeile. Ein Kreis wird immer 		dann genutzt, wenn für den entsprechenden Block keine oder nur eine kleine Bewegung durch das 		Verfahren ermittelt wurde. Die Pfeile zeigen immer in Richtung der ermittelten Verschiebung. 			Beide Symbole haben ihren Startpunkt im Mittelpunkt des jeweiligen Blocks.\\
	Die Randbereiche der einzelnen Bewegungsvektorfelder werden bei der Visualisierung ausgespart, 
	da hier durch den Algorithmus begründete Fehlberechnungen auftreten.
	\section{Auswertung}

\subsection{Testmaterial}\label{sec:testmaterialien}
	Das Verfahren wird anhand von drei unterschiedlichen Bildsequenzen getestet, die im Folgenden 		Testmaterial 1-3 genannt werden und alle eine Auflösung von 256x2656 Pixeln haben. Bei 				Testmaterial 1 und Testmaterial 2 wurde ein Bild um bekannte Werte in x- und y-Richtung 				verschoben. Anzumerken ist auch, dass beide Testmaterialien identisch verschoben wurden. Bei 			Testmaterial 3 kann die Bewegung der zu sehenden Objekte lediglich geschätzt werden. Alle 			Testmaterialien wurden für diese Dokumentation aufgenommen bzw. erstellt.\vspace{0.6cm}

\begin{minipage}{0.5\textwidth}
	\begin{figure}[H] 
		\includegraphics[bb=0 0 256 256, width=.95\linewidth]{Testmaterial1.jpg}
			\label{fig:testmaterial1}
			\caption{Standbild Testmaterial 1.}
	\end{figure}
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\textbf{Testmaterial 1}\\
	Diese Bildsequenz besteht aus 150 Frames und wurde aus einem Bild der Stadt Köln erzeugt.\\ 
	Bei den ersten und letzten 50 Frames wird ein Ausschnitt des Bildes um jeweils 10 Pixel 				nach links bzw. oben verschoben. In den mittleren 50 Frames  wird der Bildinhalt um 10 				Pixel nach links und 10 Pixel nach unten verschoben. 
	\vspace{2.0cm}\\
\end{minipage}\vspace{0.7cm}

\begin{minipage}{0.5\textwidth}
	\begin{figure}[H] 
		\includegraphics[bb=0 0 256 256, width=.95\linewidth]{Testmaterial2.jpg}
			\label{fig:testmaterial2}
			\caption{Standbild Testmaterial 2.}
	\end{figure}
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\textbf{Testmaterial 2}\\
	Auf den 150 Frames, die diese Bildsequenz umfasst ist ein Blumenmotiv zu sehen, welches jeweils 	über 50 Frames in verschiedene Richtungen verschoben wird. Auf den ersten Frames erfolgt eine 		Verschiebung um 10 Pixel nach links. Während die mittleren Frames um sowohl 10 Pixel nach 			links, als auch 10 Pixel nach oben verschoben wurden, wurde der Bildinhalt der verbleibenden 			Frames nur um 10 Pixel nach oben verschoben.
	\vspace{0.9cm}\\
\end{minipage}\vspace{0.7cm}


\begin{minipage}{0.5\textwidth}
	\begin{figure}[H] 
		\includegraphics[bb=0 0 256 256, width=.95\linewidth]{Testmaterial3.jpg}
			\label{fig:testmaterial3}
			\caption{Standbild Testmaterial 3.}
	\end{figure}
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\textbf{Testmaterial 3}\\
	Bei Testmaterial 3 handelt es sich um eine reale Videosequenz, die in Köln Ehrenfeld 					aufgenommen wurde. Zu sehen sind ein Auto, dass sich von links nach rechts durch das Bild 			bewegt und eine Fahrradfahrerin, die das Bild genau entgegengesetzt durchfährt. Beide Objekte 		werden zeitweise durch verschiedene Objekte verdeckt. Die Kamera ist starr, weshalb für den 			restlichen Bildinhalt keine Bewegung zu erkennen ist. Insgesamt besteht die Testsequenz aus 118 	Frames.
	\vspace{0.4cm}\\
\end{minipage}

\subsection{Auswertung der Testmaterialien}\label{AuswertungTestmaterialien}
Im Folgenden wird das Verfahren anhand der in Kapitel \ref{sec:testmaterialien} aufgeführten Testmaterialien ausgewertet. Dabei wurden für alle Materialien die gleichen Einstellungsparameter gewählt:
\begin{itemize} 
\item[$\bullet$] 5 Iterationen
\item[$\bullet$] $\nu$ = 1.5
\item[$\bullet$] $\lambda$ = 0.3 und $\lambda$\textsubscript{T} = 0.3
\end{itemize}

In Abbildung \ref{fig:testmaterial12} sind jeweils drei Bewegungsvektorfelder für Testmaterial 1 und Testmaterial 2 zu sehen. Es ist deutlich erkennbar, dass die Bewegungsdetektion sowohl für hochfrequente, als auch für tieffrequente Bildinhalte funktioniert hat. \\
Die Abweichungen der berechneten von den tatsächlichen Bewegungsvektoren können bestimmt werden, da die Bewegung bekannt ist. Da sich alle Blöcke eines Frames mit der selben Geschwindigkeit in die selbe Richtung bewegen, kann die absolute Längenabweichung der einzelnen Vektoren über ein Frame aufsummiert und durch die Anzahl der Blöcke geteilt werden um ein Maß für die absolute Abweichung zu erhalten.\\
Schaut man sich die so ermittelten Abweichungen für ein Frame an, wo in den vorherigen Frames keine Richtungsänderung  stattgefunden hat, so beträgt diese im Durchschnitt für beide Testmaterialien ungefähr ein halbes Pixel. Da es wie in Kapitel \ref{sec:Einschwingverhalten} näher beschrieben dauert, bis die Bewegungsvektoren eingeschwungen sind, kommt es in den Frames 50 und 100 in beiden Testmaterialien zu einer Abweichung von bis zu 8 Pixeln. Das sind eben die Frames, wo sich die Bewegung verändert. \\

\begin{figure}[H] 
		\centering
		\includegraphics[bb=0 0 1540 1024, width=\textwidth]{testmaterial12.jpg} 
			\caption{Bewegungsvektorfelder (v.\,l.\,n.\,r.): Frame 10, Frame 60 und Frame 110.\newline Oben Testmarial 1 und unten Testmaterial 2.}
			\label{fig:testmaterial12}
	\end{figure}

Da es sich bei Testmaterial 3 um eine reale Videosequenz handelt, deren Bewegungsvektoren unbekannt sind, kann die Auswertung hier nur rein visuell vorgenommen werden.\\\\
Abbildung \ref{fig:frame43} und Abbildung \ref{fig:frame47} zeigen jeweils ein Standbild aus dem Bewegungsvektorfeld, welches sich unter dem Namen \textit{testmaterial3-bewegungsvektorfeld.tiff} auf der beiliegenden Daten-CD befindet.\\
Es ist deutlich zu erkennen, dass die Bereiche in denen keine Bewegung stattfindet weitgehend richtig detektiert wurden. Und auch die Bewegung des Autos und der Radfahrerin werden trotz der Verdeckung durch die Säule weitgehend erkannt. Auffällig ist, dass besonders die Blöcke, die hinter dem Auto liegen und deren Bildinhalt sich nicht mehr bewegt falsch berechnet sind. Das ist besonders gut in Abbildung \ref{fig:frame47} zu sehen und lässt sich auf das Einschwingverhalten zurückführen. Dieses wird in Kapitel \ref{sec:Einschwingverhalten} erklärt und ausgewertet.\\

\begin{minipage}{0.5\textwidth}
	\begin{figure}[H] 
		\includegraphics[bb=0 0 517 516, width=0.9\textwidth]{frame43.png}
			\caption{Bewegungsvektorfeld \newline Testmaterial 3. Frame 43.}
		\label{fig:frame43}
	\end{figure}
\end{minipage}
\begin{minipage}{0.5\textwidth}
	\begin{figure}[H] 
		\includegraphics[bb=0 0 514 515, width=0.9\textwidth]{frame47.png}
			\caption{Bewegungsvektorfeld \newline Testmaterial 3. Frame 47.}
		\label{fig:frame47}
	\end{figure}
\end{minipage}\vspace{0.7cm}

Alle erzeugten Bewegungsvektorfelder können auf der beiliegenden Daten-CD eingesehen werden. Die Dateien heißen \textit{bvf-1.tiff}, \textit{bvf-2.tiff} und \textit{bvf-3.tiff}.

\subsection{Einschwingverhalten} \label{sec:Einschwingverhalten}
Als Ausgangspunkt werden alle Bewegungsvektorfelder zu Beginn des Algorithmus auf den Nullvektor gesetzt. Das Verfahren muss sich also zunächst Einschwingen. Dabei wird im Folgenden zwischen dem interframe und dem intraframe Einschwingen unterschieden.	

\subsubsection{Bewegungsvektorfelder}\label{sec:bvf}

Im Folgenden wird das Konvergenzverhalten des Verfahrens über die Bilderfolgen  untersucht.
Zur Auswertung wird das \textit{Testmaterial 1} und das \textit{Testmaterial 2} benutzt.
Die Parametereinstellungen werden wie folgt festgelegt:

\begin{itemize} 
\item[$\bullet$] 5 Iterationen
\item[$\bullet$] $\nu$ = 1.3
\item[$\bullet$] $\lambda$ = 0.001 und $\lambda$\textsubscript{T} = 0.001
\item[$\bullet$] Bewegungsvektor $\left(\begin{array}{c} x\\y \end{array} \right) = \left(\begin{array}{c} 10\\0 \end{array} \right)$
\end{itemize}

Um das Konvergenzverhalten des Verfahrens zu untersuchen wird die Abweichung des geschätzten Bewegungsvektorfeldes zum realen (und bekannten) Bewegungsvektorfeld über die Bildfolge bestimmt.
Zum Bemessen der Abweichung wird der relative Fehler der einzelnen Vektoren ermittelt, aufsummiert und anschließend durch die Gesamtanzahl der Bewegungsvektoren gemittelt.
Abbildung~\ref{fig:einschwingFrame} veranschaulicht das Konvergenzverhalten der zwei Bildfolgen.
Spätestens nach der siebten Bildfolge konvergiert das Verfahren.
Neben den Einstellungen für $\nu$,$\lambda$ und $\lambda_T$ wird das Konvergenzverhalten durch den Bildinhalt des Testmaterials beeinflusst.

		\begin{comment}
			\begin{figure}[H]
				\psset{xunit=1cm,yunit=.5mm}
					\begin{pspicture}(-0.5,-20)(12,130)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,yAxis=false]{->}(1,0)(10.5,100)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,xAxis=false]{-}(1,0)(10.5,100)
					\rput[l](-0.5,115){Abweichung [\%]}
					\rput[l](11,0){Bild des Testmaterials}
					\rput[l](9,80){Testmaterial 1 (Stadt)}							
					\psline[linecolor=red,linewidth=1pt]{-}(8,80)(8.75,80)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,80)(8.75,80)
					\rput[l](9,68){Testmaterial 2 (Blume)}
					\psline[linecolor=blue,linewidth=1pt]{-}(8,68)(8.75,68)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,68)(8.75,68)
					\listplot[linecolor=red,linewidth=1pt]{
						1	100
						2	83.5
						3	75
						4	67.9
						5	61.8
						6	7.5
						7	0
						8	0
						9	0
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	83.5
						3	75
						4	67.9
						5	61.8
						6	7.5
						7	0
						8	0
						9	0
						10	0}
					\listplot[linecolor=blue,linewidth=1pt]{
						1	100
						2	77.5
						3	60.3
						4	45.1
						5	1.6
						6	0
						7	0
						8	0
						9	0
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	77.5
						3	60.3
						4	45.1
						5	1.6
						6	0
						7	0
						8	0
						9	0
						10	0}
					\end{pspicture}			
				\caption{Einschwingverhalten der Bewegungsvektorfelder über die ersten 10 Bilder von Testmaterial 1 und 2.}
				\label{fig:einschwingFrame}
			\end{figure}
		\end{comment}
		
		\subsubsection{Innerhalb eines Bildes}\todo[inline]{Laura}
Wie in Kapitel \ref{sec:programmAblauf} beschrieben wird die Bewegungsdetektion in jedem Frame über mehrere Iterationen hinweg ermittelt. Mit anderen Worten: $V_{n}$ wird in jeder Iteration neu gesetzt und man kann davon sprechen. Im Folgenden wird die Veränderung der Vektoren nach jeder Iteration betrachtet. Dabei werden die Parameter wie in Kapitel \ref{AuswertungTestmaterialien} gewählt.

		\begin{comment}
			\begin{figure}[H]
				\psset{xunit=1cm,yunit=.5mm}
					\begin{pspicture}(-0.5,-20)(12,130)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,yAxis=false]{-}(1,0)(5,100)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,xAxis=false]{-}(1,0)(5,100)
					\rput[l](-0.5,115){Abweichung [\%]}
					\rput[l](5.5,0){Iteration}
					\rput[l](8,92){Bild 1}
					\psline[linecolor=red,linewidth=1pt]{-}(7,92)(7.75,92)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(7,92)(7.75,92)
					\rput[l](8,80){Bild 2}
					\psline[linecolor=blue,linewidth=1pt]{-}(7,80)(7.75,80)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(7,80)(7.75,80)
					\rput[l](8,68){Bild 3}
					\psline[linecolor=green,linewidth=1pt]{-}(7,68)(7.75,68)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(7,68)(7.75,68)
					\rput[l](8,56){Bild 4}
					\psline[linecolor=orange,linewidth=1pt]{-}(7,56)(7.75,56)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(7,56)(7.75,56)
					\rput[l](8,44){Bild 5}
					\psline[linecolor=yellow,linewidth=1pt]{-}(7,44)(7.75,44)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(7,44)(7.75,44)
					\rput[l](8,32){Bild 6}
					\psline[linecolor=cyan,linewidth=1pt]{-}(7,32)(7.75,32)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(7,32)(7.75,32)
					% frame 1
					\listplot[linecolor=red,linewidth=1pt]{
						1	95.2885842
						2	91.2961733
						3	88.4551491
						4	85.6458496
						5	83.5249551}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	95.2885842
						2	91.2961733
						3	88.4551491
						4	85.6458496
						5	83.5249551}
					% frame 2
					\listplot[linecolor=blue,linewidth=1pt]{
						1	81.4226184
						2	79.5418027
						3	77.8162246
						4	76.2804576
						5	75.0459657}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	81.4226184
						2	79.5418027
						3	77.8162246
						4	76.2804576
						5	75.0459657}
					% frame 3
					\listplot[linecolor=green,linewidth=1pt]{
						1	72.3237662
						2	71.1472612
						3	69.720132
						4	68.7000229
						5	67.8523882}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	72.3237662
						2	71.1472612
						3	69.720132
						4	68.7000229
						5	67.8523882}
					% frame 4
					\listplot[linecolor=orange,linewidth=1pt]{
						1	64.298924
						2	63.7272028
						3	63.0797129
						4	62.4292025
						5	61.7874485}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	64.298924
						2	63.7272028
						3	63.0797129
						4	62.4292025
						5	61.7874485}
					% frame 5
					\listplot[linecolor=yellow,linewidth=1pt]{
						1	50.3405223
						2	47.6418829
						3	21.9161035
						4	10.9143968
						5	07.4779145}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	50.3405223
						2	47.6418829
						3	21.9161035
						4	10.9143968
						5	07.4779145}
					% frame 6
					\listplot[linecolor=cyan,linewidth=1pt]{
						1	02.2438394
						2	01.1901277
						3	00.558221
						4	00.1330726
						5	0.0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	0.022438394
						2	0.011901277
						3	0.00558221
						4	0.001330726
						5	0.0}
			\end{pspicture}					
			\caption{Einschwingverhalten der Bewegungsvektorfelder in Abhängigkeit der Iterationen innerhalb eines Bildes bei fünf Iterationen.}
			\label{fig:einschwingIter5}
		\end{figure}
	\end{comment}		
	
			\begin{comment}
			\begin{figure}[H]
				\psset{xunit=1cm,yunit=.5mm}
					\begin{pspicture}(-0.5,-20)(12,130)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,yAxis=false]{-}(1,0)(10,100)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,xAxis=false]{-}(1,0)(10,100)
					\rput[l](-0.5,115){Abweichung [\%]}
					\rput[l](10.5,0){Iteration}
					\rput[l](9,44){Bild 1}
					\psline[linecolor=red,linewidth=1pt]{-}(8,44)(8.75,44)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,44)(8.75,44)
					\rput[l](9,32){Bild 2}
					\psline[linecolor=blue,linewidth=1pt]{-}(8,32)(8.75,32)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,32)(8.75,32)
					\rput[l](9,20){Bild 3}
					\psline[linecolor=green,linewidth=1pt]{-}(8,20)(8.75,20)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,20)(8.75,20)					
					% frame 1
					\listplot[linecolor=red,linewidth=1pt]{
						1	95.2885842
						2	91.2961733
						3	88.4551491
						4	85.6458496
						5	83.5249551
						6	81.287162
						7	79.6640612
						8	77.930831
						9	76.4122635
						10	75.2230274}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	95.2885842
						2	91.2961733
						3	88.4551491
						4	85.6458496
						5	83.5249551
						6	81.287162
						7	79.6640612
						8	77.930831
						9	76.4122635
						10	75.2230274}
					% frame 2
					\listplot[linecolor=blue,linewidth=1pt]{
						1	72.2582365
						2	70.3882259
						3	69.0534415
						4	68.0520747
						5	66.6586773
						6	66.0073828
						7	65.6195556
						8	65.1202407
						9	64.691025
						10	64.4321682}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	72.2582365
						2	70.3882259
						3	69.0534415
						4	68.0520747
						5	66.6586773
						6	66.0073828
						7	65.6195556
						8	65.1202407
						9	64.691025
						10	64.4321682}
					% frame 3
					\listplot[linecolor=green,linewidth=1pt]{
						1	39.3824754
						2	33.4164411
						3	29.9361794
						4	23.4618736
						5	17.9897871
						6	13.7384903
						7	04.4049927
						8	01.4629727
						9	00.4225138
						10	00.385155}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	39.3824754
						2	33.4164411
						3	29.9361794
						4	23.4618736
						5	17.9897871
						6	13.7384903
						7	04.4049927
						8	01.4629727
						9	00.4225138
						10	00.385155}					
			\end{pspicture}					
			\caption{Einschwingverhalten der Bewegungsvektorfelder in Abhängigkeit der Iterationen innerhalb eines Bildes bei zehn Iterationen.}
			\label{fig:einschwingIter10}
		\end{figure}
	\end{comment}		

		\subsection{Parameter der Regularisierungsterme}
		
Der folgende Abschnitt untersucht die geeignete Parametrisierung der Gewichtungen $\lambda$ und $\lambda_T$ der zwei Regularisierungsterme.
Wie in {\cite{aach1998bayesian}} beschrieben, ist es möglich über die zwei Faktoren die Varianz der verallgemeinerten Normalverteilung zu modifizieren.
Eine geeignete Parametrisierung kann demnach das Konvergenzverhalten des Verfahrens positiv beeinflussen. \\

Die Untersuchungen werden auf Basis von \textit{Testmaterial 1} durchgeführt.
Es gilt $\nu=1.3$. Der Bewegungsvektor ist $\left(\begin{array}{c} x\\y \end{array} \right) = \left(\begin{array}{c} 10\\0 \end{array} \right)$.
In Tabelle \ref{fig:einschwingRegula} wird das Einschwingen der ersten 10 Bewegungsvektorfelder unter Variation von $\lambda$ und $\lambda_T$ betrachtet.
Zur Bestimmung der Abweichung des geschätzten Bewegungsvektorfeldes wird wie in \ref{sec:bvf} verfahren. \\
		
		
		\begin{comment}
			\begin{figure}[H]
				\psset{xunit=1cm,yunit=.5mm}
					\begin{pspicture}(-0.5,-20)(12,130)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,yAxis=false]{->}(1,0)(10.5,100)
					\psaxes[Ox=1,Dx=1,Dy=20,xsubticks=4,ysubticks=2,xAxis=false]{-}(1,0)(10.5,100)
					\rput[l](-0.5,115){Abweichung [\%]}
					\rput[l](11,0){Bild des Testmaterials}
					\rput[l](9,92){$\lambda, \lambda_T=0.0$}
					\psline[linecolor=red,linewidth=1pt]{-}(8,92)(8.75,92)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,92)(8.75,92)
					\rput[l](9,80){$\lambda, \lambda_T=0.001$}
					\psline[linecolor=blue,linewidth=1pt]{-}(8,80)(8.75,80)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,80)(8.75,80)
					\rput[l](9,68){$\lambda, \lambda_T=0.01$}
					\psline[linecolor=green,linewidth=1pt]{-}(8,68)(8.75,68)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,68)(8.75,68)
					\rput[l](9,56){$\lambda, \lambda_T=0.1$}
					\psline[linecolor=orange,linewidth=1pt]{-}(8,56)(8.75,56)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,56)(8.75,56)
					\rput[l](9,44){$\lambda, \lambda_T=1.0$}
					\psline[linecolor=yellow,linewidth=1pt]{-}(8,44)(8.75,44)
					\psline[linestyle=none,linewidth=0.125pt]{*-*}(8,44)(8.75,44)
					% \lambda = 0
					\listplot[linecolor=red,linewidth=1pt]{
						1	100
						2	83.4
						3	74.5
						4	67.1
						5	60.4
						6	17.6
						7	0.7
						8	0
						9	0
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	83.4
						3	74.5
						4	67.1
						5	60.4
						6	17.6
						7	0.7
						8	0
						9	0
						10	0}
					% \lambda = 0.001
					\listplot[linecolor=blue,linewidth=1pt]{
						1	100
						2	83.5
						3	75
						4	67.9
						5	61.8
						6	7.5
						7	0
						8	0
						9	0
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	83.5
						3	75
						4	67.9
						5	61.8
						6	7.5
						7	0
						8	0
						9	0
						10	0}
					% \lambda = 0.01
					\listplot[linecolor=green,linewidth=1pt]{
						1	100
						2	83.5
						3	75.1
						4	67.9
						5	61.6
						6	8.9
						7	0
						8	0
						9	0
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	83.5
						3	75.1
						4	67.9
						5	61.6
						6	8.9
						7	0
						8	0
						9	0
						10	0}
					% \lambda = 0.1
					\listplot[linecolor=orange,linewidth=1pt]{
						1	100
						2	83.6
						3	75.6
						4	68.8
						5	62.1
						6	40.4
						7	0.9
						8	0
						9	0
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	83.6
						3	75.6
						4	68.8
						5	62.1
						6	40.4
						7	0.9
						8	0
						9	0
						10	0}
					% \lambda = 1
					\listplot[linecolor=yellow,linewidth=1pt]{
						1	100
						2	84.2
						3	76.4
						4	70.6
						5	65.7
						6	57.7
						7	34.5
						8	5.3
						9	1.6
						10	0}
					\listplot[linewidth=.025pt,plotstyle=dots]{
						1	100
						2	84.2
						3	76.4
						4	70.6
						5	65.7
						6	57.7
						7	34.5
						8	5.3
						9	1.6
						10	0}								
			\end{pspicture}					
			\caption{Einschwingverhalten der Bewegungsvektorfelder in Abhängigkeit der Regularisierungsparameter $\lambda$ und $\lambda_T$.}
			\label{fig:einschwingRegula}
		\end{figure}
	\end{comment}			
	
		\begin{table}[H]
		\centering
		\begin{tabular}{r|r|r|r|r|r}
			\multirow{2}{*}{Bild} &\multicolumn{5}{c}{Abweichung für $\lambda, \lambda_T=\dots$}	\\
														& 0.0 			& 0.001 		& 0.01 			& 0.1 			& 1.0						\\
			\hline
			1 										& 100.0\,\%	& 100.0\,\%	& 100.0\,\%	& 100.0\,\%	& 100.0\,\%			\\
			2 										& 83.4\,\%	& 83.5\,\%	& 83.5\,\%	& 83.6\,\%	& 84.2\,\%			\\
			3 										& 74.5\,\%	& 75.0\,\%	& 75.1\,\%	& 75.6\,\%	& 76.4\,\%			\\
			4 										& 67.1\,\%	& 67.9\,\%	& 67.9\,\%	& 68.8\,\%	& 70.6\,\%			\\
			5 										& 60.4\,\%	& 61.8\,\%	& 61.6\,\%	& 62.1\,\%	& 65.7\,\%			\\
			6 										& 17.6\,\%	& 7.5\,\%		& 8.9\,\%		& 40.4\,\%	& 57.7\,\%			\\
			7 										& 0.7\,\%		& 0.0\,\%		& 0.0\,\%		& 0.9\,\%		& 34.5\,\%			\\
			8 										& 0.0\,\%		& 0.0\,\%		& 0.0\,\%		& 0.0\,\%		& 5.3\,\%				\\
			9 										& 0.0\,\%		& 0.0\,\%		& 0.0\,\%		& 0.0\,\%		& 1.6\,\%				\\
			10 										& 0.0\,\%		& 0.0\,\%		& 0.0\,\%		& 0.0\,\%		& 0.0\,\%				\\
		\end{tabular}				
		\caption{Werte zu Abbildung~\ref{fig:einschwingRegula}.}
		\label{tab:einschwingRegulaWerte}
		\end{table}

Sowohl für $\lambda$ als auch für $\lambda_T$ werden dieselben Größen eingestellt.
Nach spätestens 10 Bildfolgen konvergiert das Verfahren für jede der betrachteten Parametrisierungen.
Für die Werte $0.001$ und $0.01$ konvergiert das Verfahren bereits nach sieben Bildfolgen vollständig. Zu beachten ist hierbei, dass für $\lambda=0.001$ und $\lambda_T=0.001$ die Abweichung des geschätzten Bewegungsvektorfeldes bereits nach der sechsten Bildfolge am geringsten ist (ca. 7.5\,\%).
Wie Tabelle \ref{tab:einschwingRegulaWerte} zu entnehmen ist, nimmt für größere Werte das Konvergenzverhalten ab.
Die Wahl von $\lambda=0.001$ und $\lambda_T=0.001$ liefert das Optimum für die betrachteten Einstellungen.


	\section{Zusammenfassung}
		Das Projekt, den Ansatz von Aach und Kunz\textsuperscript{\cite{aach1998bayesian}} auf normale Bildsequenzen zu übertragen und so eine robuste Methode zur Bewegungsschätzung von Realvideo-Sequenzen zu erhalten, konnte erfolgreich abgeschlossen werden.\\ 
		Es wurde die Algorithmik an die geänderten Daten angepasst und in diesem Zuge das spezielle Rauschmodell für Röntgenaufnahmen vernachlässigt.\\
		Für die Auswertung wurden drei verschiedene Testmaterialien erstellt, von denen zwei lediglich Standbilder enthalten, welche über den Bildausschnitt über die Zeit verschoben werden, sodass die tatsächliche Bewegung im Bild bekannt ist und als Grundwahrheit angenommen werden kann. Die verbleibende Testsequenz wurde ausgewählt, da diese Bewegungen von Realobjekten in verschiedenen Bewegungen, eine statische Kameraposition und zeitweise Verdeckungen der beiden Bewegungen bot. Die Auswertung anhand des Testmaterials hat gezeigt, dass die Bewegungsschätzung hinreichend gut für die verwendeten Testmaterialien funktioniert.\\ Des Weiteren belegt die Auswertung der Einschwingverhalten über die Iterationen pro Bild, dass -- ähnlich wie im Paper von Aach und Kunz\textsuperscript{\cite{aach1998bayesian}} -- eine signifikante Verbesserung der Ergebnisse über fünf bis zehn Iterationen erreicht werden kann.\\ Es stellt sich auch heraus, dass es zu Beginn einer Bildsequenz einige Bilder dauert, bis sich der Fehler der Bewegungsschätzung auf ein akzeptables Niveau gesunken ist.\\
		
		Insgesamt bewegen sich die Ergebnisse der Untersuchung in einem erwartbaren Bereich, da bei einer Anpassung des Verfahrens von Röntgen- auf normale Bildsequenzen keine starken Abweichungen eintreten sollten.
	
	\section{Arbeitsaufteilung}\todo[inline]{Alle}
	\newpage
	\bibliographystyle{plain}
	\bibliography{ABV_Bewegungsanalyse_LaTeX}
\end{document}
		